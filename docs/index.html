<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />


<meta name="author" content="Erik Bernhardson (Engineering)" />
<meta name="author" content="David Causse (Engineering &amp; Report)" />
<meta name="author" content="Trey Jones (Engineering &amp; Review)" />
<meta name="author" content="Mikhail Popov (Analysis &amp; Report)" />
<meta name="author" content="Deb Tankersley (Product Management)" />
<meta name="author" content="Chelsy Xie (Review)" />

<meta name="date" content="2016-10-11" />

<title>Improving search result relevancy on Wikipedia with BM25 ranking</title>

<script src="index_files/jquery-1.11.3/jquery.min.js"></script>
<script src="index_files/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="index_files/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="index_files/tocify-1.9.1/jquery.tocify.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="index_files/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="index_files/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="index_files/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="index_files/bootstrap-3.3.5/shim/respond.min.js"></script>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #303030; color: #cccccc; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; }
td.sourceCode { padding-left: 5px; }
pre, code { color: #cccccc; background-color: #303030; }
code > span.kw { color: #f0dfaf; } /* Keyword */
code > span.dt { color: #dfdfbf; } /* DataType */
code > span.dv { color: #dcdccc; } /* DecVal */
code > span.bn { color: #dca3a3; } /* BaseN */
code > span.fl { color: #c0bed1; } /* Float */
code > span.ch { color: #dca3a3; } /* Char */
code > span.st { color: #cc9393; } /* String */
code > span.co { color: #7f9f7f; } /* Comment */
code > span.ot { color: #efef8f; } /* Other */
code > span.al { color: #ffcfaf; } /* Alert */
code > span.fu { color: #efef8f; } /* Function */
code > span.er { color: #c3bf9f; } /* Error */
code > span.wa { color: #7f9f7f; font-weight: bold; } /* Warning */
code > span.cn { color: #dca3a3; font-weight: bold; } /* Constant */
code > span.sc { color: #dca3a3; } /* SpecialChar */
code > span.vs { color: #cc9393; } /* VerbatimString */
code > span.ss { color: #cc9393; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { } /* Variable */
code > span.cf { color: #f0dfaf; } /* ControlFlow */
code > span.op { color: #f0efd0; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #ffcfaf; font-weight: bold; } /* Preprocessor */
code > span.at { } /* Attribute */
code > span.do { color: #7f9f7f; } /* Documentation */
code > span.an { color: #7f9f7f; font-weight: bold; } /* Annotation */
code > span.cv { color: #7f9f7f; font-weight: bold; } /* CommentVar */
code > span.in { color: #7f9f7f; font-weight: bold; } /* Information */
div.sourceCode {
  overflow-x: visible;
}
</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>


<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />

</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<div class="container-fluid main-container">

<!-- tabsets -->
<script src="index_files/navigation-1.1/tabsets.js"></script>
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->
<script src="index_files/navigation-1.1/codefolding.js"></script>
<script>
$(document).ready(function () {
  window.initializeCodeFolding("hide" === "show");
});
</script>




<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3,h4",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = false;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.9em;
  padding-left: 5px;
}

.tocify .list-group-item {
  border-radius: 0px;
}

.tocify-subheader {
  display: inline;
}
.tocify-subheader .tocify-item {
  font-size: 0.95em;
  padding-left: 10px;
}

</style>

<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="fluid-row" id="header">

<div class="btn-group pull-right">
<button type="button" class="btn btn-default btn-xs dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Improving search result relevancy on Wikipedia with BM25 ranking</h1>
<h4 class="author"><em><a href = 'https://meta.wikimedia.org/wiki/User:EBernhardson_(WMF)'>Erik Bernhardson</a> (Engineering)</em></h4>
<h4 class="author"><em><a href = 'https://www.mediawiki.org/wiki/User:DCausse_(WMF)'>David Causse</a> (Engineering &amp; Report)</em></h4>
<h4 class="author"><em><a href = 'https://meta.wikimedia.org/wiki/User:TJones_(WMF)'>Trey Jones</a> (Engineering &amp; Review)</em></h4>
<h4 class="author"><em><a href = 'https://meta.wikimedia.org/wiki/User:MPopov_(WMF)'>Mikhail Popov</a> (Analysis &amp; Report)</em></h4>
<h4 class="author"><em><a href = 'https://meta.wikimedia.org/wiki/User:DTankersley_(WMF)'>Deb Tankersley</a> (Product Management)</em></h4>
<h4 class="author"><em><a href = 'https://meta.wikimedia.org/wiki/User:CXie_(WMF)'>Chelsy Xie</a> (Review)</em></h4>
<h4 class="date"><em>11 October 2016</em></h4>

</div>


<script language="JavaScript">
$(function() {
  /* Lets the user click on the images to view them in full resolution. */
  $("div.figure img").wrap(function() {
    var link = $('<a/>');
    link.attr('href', $(this).attr('src'));
    link.attr('title', $(this).attr('alt'));
    link.attr('target', '_blank');
    return link;
  });
});
</script>
<p>
{ <a href="https://github.com/wikimedia-research/Discovery-Search-Test-BM25/blob/master/docs/index.Rmd">RMarkdown Source</a> | <a href="https://github.com/wikimedia-research/Discovery-Search-Test-BM25">Analysis Codebase</a> }
</p>
<div id="executive-summary" class="section level2">
<h2>Executive Summary</h2>
<p>In order to improve the relevancy of search results, Discovery’s Search team has decided to test a new document ranking function called <a href="https://en.wikipedia.org/wiki/Okapi_BM25">BM25</a>, which would replace the Lucene classic similarity that is currently used. We saw the following results from our analysis:</p>
<dl>
<dt><span class="test-group-2 no-italics">█</span> Same “all field” query builder as control group but using BM25 as similarity function</dt>
<dd>For searches made by users in this group, we use the same query builder as we use for the control group, but we switched the similarity function to BM25 and employ a weighted sum for the incoming links query independent factor (QIF). Users in this group were less likely to click on the 1st search result and instead more likely to click on the second search result. They were also more likely to reformulate their query. With regards to zero results rate (ZRR), <a href="https://www.mediawiki.org/wiki/Wikimedia_Discovery/Search/Glossary#PaulScore">PaulScore</a>, and engagement, users in this group were very similar to users in the control group.
</dd>
<dt><span class="test-group-3 no-italics">█</span> Using per-field query building with incoming links as QIF</dt>
<dd>For searches made by users in this group, we use BM25 similarity and switch to a per-field query builder using only incoming links as a query independent factor. This group had the second-highest PaulScores and engagement in searches where the user reformulated their query. Users in this group were more likely to click on the first search result than users in the control group.
</dd>
<dt><span class="test-group-4 no-italics">█</span> Using per-field query builder with incoming links and pageviews as QIFs</dt>
<dd>Similar to <span class="test-group-3">the group described above</span> but we added pageviews as an additional query independent factor for searches made by users in this group. This group had the highest PaulScores and engagement, both in searches where the user reformulated their query and in searches without query reformulation. Users in this group were a lot more likely to click on the first search result than users in the control group.
</dd>
<dt><span class="test-group-5 no-italics">█</span> Track typos in first 2 characters</dt>
<dd>Similar to <span class="test-group-4">the group described above</span>, but with an additional field to track typos in the first two characters. This group had the lowest ZRR, and its ZRR was significantly smaller than the control group’s ZRR. This group also had the smallest proportion of searches where the user reformulated their query. Users in this group were a lot more likely to click on the first search result than users in the control group, but had lowest overall engagement with the search results.
</dd>
</dl>
<p>We recommend switching to BM25 ranking with incoming links (and possibly pageviews) as query-independent factors, as this configuration appears to give users results that are more relevant and that they engage with more (especially the first search result).</p>
</div>
<div id="background" class="section level2">
<h2>Background</h2>
<p>The Discovery department’s mission is to help users discover and access knowledge on Wikipedia and other Wikimedia projects. One of the goals of Discovery’s Search team is to improve the relevance of results when users search Wikipedia and its sister projects. Currently, our search engine uses <a href="https://lucene.apache.org/core/5_5_0/core/org/apache/lucene/search/similarities/TFIDFSimilarity.html">Lucene classic similarity</a> to rank articles using <a href="https://en.wikipedia.org/wiki/Tf%E2%80%93idf">term frequency–inverse document frequency (tf–idf)</a>. To improve the search results, we decided to try a new document-ranking function: <a href="https://en.wikipedia.org/wiki/Okapi_BM25">Okapi BM25</a> (BM stands for Best Matching). To assess the efficacy of the proposed switch, we ran an A/B test for 10 days and anonymously tracked randomly sampled search sessions. Some users received search results acquired through the Lucene similarity, while others received search results acquired through BM25 with various configurations. We are primarily interested in:</p>
<ul>
<li><strong>Zero results rate</strong>, the proportion of searches that yielded zero results (smaller is better)</li>
<li><strong>Users’ engagement</strong> with the search results, measured as the clickthrough rate (bigger is better)</li>
<li><strong>PaulScore</strong>, a metric of search results’ relevancy that relies on the position of the clicked result[s] (bigger is better); see <a href="#paulscore-definition">PaulScore Definition</a> below for more details</li>
<li><strong>Query reformulation</strong> – one way to think about the strength of our search engine is how many times the user reformulates their query; if a user in the test group has to reformulate their query many more times to get the results they are interested in, then maybe the change is for the worse</li>
</ul>
</div>
<div id="methods" class="section level2">
<h2>Methods</h2>
<div id="data" class="section level3">
<h3>Data</h3>
<p>Users who searched <a href="https://en.wikipedia.org/wiki/Main_Page">English Wikipedia</a> (“enwiki”) had a 1 in 66 chance of being selected for search satisfaction tracking according to our <a href="https://meta.wikimedia.org/w/index.php?title=Schema:TestSearchSatisfaction2&amp;oldid=15700292">TestSearchSatisfaction2 #15700292</a> schema. See change <a href="https://gerrit.wikimedia.org/r/#/c/307536/">307536</a> on Gerrit for more details. Those users who were on enwiki and were randomly selected to have their sessions anonymously tracked then had a 2 in 3 chance of being selected for the BM25 test.</p>
<p>Users who were randomly selected for the A/B test were then randomly assigned to one of five groups. For all the groups listed below, we include the normalized <a href="https://en.wikipedia.org/wiki/Discounted_cumulative_gain">discounted cumulative gain</a> (<a href="https://en.wikipedia.org/wiki/Discounted_cumulative_gain#Normalized_DCG">nDCG</a>) score – a measure of ranking quality – computed from ranking data collected through <a href="https://www.mediawiki.org/wiki/Wikimedia_Discovery/Search/Glossary#Discernatron">Discernatron</a>, a tool that allows participants to judge the relevance of search results to help the Search team be able to test changes before making them available on-wiki.</p>
<dl>
<dt><span class="test-group-1">Control Group (tf–idf)</span></dt>
<dd>Identical to what we serve to our users today plus an artificial latency to compensate the fact that we run the other buckets on another data center. (nDCG<sub>5</sub> score on Discernatron: 0.2772)
</dd>
<dt><span class="test-group-2">Same “all field” query builder as control group but using BM25 as similarity function</span></dt>
<dd>For searches made by users in this group, we use the same query builder as we use for <span class="test-group-1">the control group</span> but we switched the similarity function to BM25 and employ a weighted sum for the incoming links query independent factor (QIF). We expected this bucket to behave poorly in term of clickthrough compared to the control group. We included this group confirm our assumptions that the current query builder and the “all field” approach is not designed for the BM25 similarity. (nDCG<sub>5</sub> score on Discernatron: 0.2689)
</dd>
<dt><span class="test-group-3">Using per-field query building with incoming links as QIF</span></dt>
<dd>For searches made by users in this group, we use BM25 similarity and switch to a per-field query builder using only incoming links as a query independent factor. This is the best contender according to Discernatron. We expect an increase in clickthrough because it tends rank obvious matches in the top 3. (nDCG<sub>5</sub> score on Discernatron: 0.3362)
</dd>
<dt><span class="test-group-4">Using per-field query builder with incoming links and pageviews as QIFs</span></dt>
<dd>Similar to <span class="test-group-3">the group described above</span> but we added pageviews as an additional query independent factor for searches made by users in this group. The weight for pageviews is still very low compared to incoming links and this test is mostly to see how pageviews could affect the ranking. We expect a very minimal difference in behavior compared to group <em>using per-field query building with incoming links as QIF</em>. (nDCG<sub>5</sub> score on Discernatron: 0.3359)
</dd>
<dt><span class="test-group-5">Track typos in first 2 characters</span></dt>
<dd>Similar to <span class="test-group-4">the group described above</span>, but with an additional field to track typos in the first two characters. We expect a slight decrease in zero result rate and hope for an increase in clickthrough rate. This test is added to measure the benefit of such a field. The question of interest we hope to answer is: Will this increase in noise provide more annoying suggestions or will it help our users? (This feature can’t be really tested with Discernatron today.)
</dd>
</dl>
<p>The “all field” field approach combines raw term frequency and field weights at index time, it creates an artificial field where the content of each field is copied <em>n</em> times:</p>
<ul>
<li>A word in the title is copied 20 times</li>
<li>A word in the title is copied 15 times</li>
</ul>
<p>At query time, we use this single all weighted field. The per field builder approach combines scores of individual fields at query time.</p>
<p>The full-text (as opposed to auto-complete) searching event logging data was extracted from the database using the following SQL query:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span>
  <span class="kw">LEFT</span>(`timestamp`, <span class="dv">8</span>) <span class="kw">AS</span> <span class="dt">date</span>,
  event_subTest <span class="kw">AS</span> test_group,
  `timestamp` <span class="kw">AS</span> ts,
  event_uniqueId <span class="kw">AS</span> event_id,
  event_mwSessionId <span class="kw">AS</span> session_id,
  event_searchSessionId <span class="kw">AS</span> search_id,
  event_pageViewId <span class="kw">AS</span> page_id,
  event_searchToken <span class="kw">AS</span> cirrus_id,
  <span class="fu">CAST</span>(event_query <span class="kw">AS</span> <span class="dt">CHAR</span> <span class="dt">CHARACTER</span> <span class="kw">SET</span> utf8) <span class="kw">AS</span> <span class="kw">query</span>,
  event_hitsReturned <span class="kw">AS</span> n_results_returned,
  event_msToDisplayResults <span class="kw">AS</span> load_time,
  <span class="kw">CASE</span> <span class="kw">WHEN</span> event_action = <span class="st">&#39;searchResultPage&#39;</span> <span class="kw">THEN</span> <span class="st">&#39;SERP&#39;</span> <span class="kw">ELSE</span> <span class="st">&#39;click&#39;</span> <span class="kw">END</span> <span class="kw">AS</span> action,
  event_position <span class="kw">AS</span> position_clicked
<span class="kw">FROM</span> TestSearchSatisfaction2_15700292
<span class="kw">WHERE</span>
  <span class="kw">LEFT</span>(`timestamp`, <span class="dv">8</span>) &gt;= <span class="st">&#39;20160830&#39;</span> <span class="kw">AND</span> <span class="kw">LEFT</span>(`timestamp`, <span class="dv">8</span>) &lt;= <span class="st">&#39;20160910&#39;</span>
  <span class="kw">AND</span> event_source = <span class="st">&#39;fulltext&#39;</span>
  <span class="kw">AND</span> <span class="kw">LEFT</span>(event_subTest, <span class="dv">4</span>) = <span class="st">&#39;bm25&#39;</span>
  <span class="kw">AND</span> (
    (event_action = <span class="st">&#39;searchResultPage&#39;</span> <span class="kw">AND</span> event_hitsReturned <span class="kw">IS</span> <span class="kw">NOT</span> <span class="kw">NULL</span> <span class="kw">AND</span> event_msToDisplayResults <span class="kw">IS</span> <span class="kw">NOT</span> <span class="kw">NULL</span>)
    <span class="kw">OR</span>
    (event_action = <span class="st">&#39;click&#39;</span> <span class="kw">AND</span> event_position <span class="kw">IS</span> <span class="kw">NOT</span> <span class="kw">NULL</span> <span class="kw">AND</span> event_position &gt; -<span class="dv">1</span>)
  )
<span class="kw">ORDER</span> <span class="kw">BY</span> <span class="dt">date</span>, wiki, session_id, search_id, page_id, action <span class="kw">DESC</span>, <span class="dt">timestamp</span>;</code></pre></div>
<p class="caption">
<strong>Snippet 1</strong>: Query used to extract BM25 test data from our event logging database.
</p>
</div>
<div id="software" class="section level3">
<h3>Software</h3>
<p>We used the statistical analysis software and programming language R<sup><a href="#ref-2">[2]</a></sup> to perform this analysis. R packages used the most in this report include ggplot2,<sup><a href="#ref-4">[4]</a></sup> dplyr,<sup><a href="#ref-5">[5]</a></sup> and binom.<sup><a href="#ref-8">[8]</a></sup></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Install packages used in the report:</span>
<span class="kw">install.packages</span>(<span class="kw">c</span>(<span class="st">&quot;devtools&quot;</span>, <span class="st">&quot;tidyverse&quot;</span>, <span class="st">&quot;binom&quot;</span>))
devtools::<span class="kw">install_github</span>(<span class="st">&quot;hadley/ggplot2&quot;</span>)
<span class="co"># ^ development version of ggplot2 includes subtitles</span>
devtools::<span class="kw">install_github</span>(<span class="st">&quot;wikimedia/wikimedia-discovery-polloi&quot;</span>)
<span class="co"># ^ for converting 100000 into 100K via polloi::compress()</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Load packages that we will be using in this report:</span>
<span class="kw">library</span>(tidyverse) <span class="co"># for ggplot2, dplyr, tidyr, broom, etc.</span>
<span class="kw">library</span>(binom) <span class="co"># for Bayesian confidence intervals of proportions</span></code></pre></div>
</div>
<div id="search-clustering" class="section level3">
<h3>Search Clustering</h3>
<p>When a user searches Wikipedia using query <span class="math inline">\(Q\)</span> and does not get the results that they were looking for then they might give up, or they might reformulate their query and search for <span class="math inline">\(Q&#39;, Q&#39;&#39;, Q&#39;&#39;&#39;\)</span>, etc., each time fixing a typo, editing a word, or adding new information. For example, if the user searches for the restaurant chain “Buffalo Wild Wings” using the search query “buffalo”, they won’t see the result on the first search results page. The user might go to the second page of results, in which case they would see the result they want, or they might reformulate their query to instead say “buffalo wings”.</p>
<p>First, we computed the <a href="https://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein (edit) distance</a> (normalized via dividing by the maximum of the two search queries’ lengths). Then we adjusted those normalized distances by the amount that their search results overlapped. Specifically, if <span class="math inline">\(d_{Q, Q&#39;}\)</span> is the edit distance between queries <span class="math inline">\(Q\)</span> and <span class="math inline">\(Q&#39;\)</span> and <span class="math inline">\(\rho_{Q, Q&#39;} \in [0, 1]\)</span> is the number of results in common normalized via dividing by the minimum of the two result sets’ sizes, then the new distance is: <span class="math display">\[{d&#39;}_{Q, Q&#39;} = \frac{d_{Q, Q&#39;}}{10^{\rho_{Q, Q&#39;}}}.\]</span> So if <span class="math inline">\(Q\)</span> and <span class="math inline">\(Q&#39;\)</span> are moderately similar but have all results in common, then the new distance is 1/10<sup>th</sup> of their initially calculated distance, and brings them a lot closer to each other. Another example is if two searches have 1 result out of 20 in common, then <span class="math inline">\(d&#39; = 10^{-0.05} d = 0.89 d\)</span>. If they do not have any results in common, their edit distance is unaffected. After we have calculated the distances between queries in a search session, we use <a href="https://en.wikipedia.org/wiki/Cluster_analysis#Connectivity-based_clustering_.28hierarchical_clustering.29">hierarchical agglomerative clustering</a> to group those queries based on their adjusted closeness (similarity). In this report we present an analysis result when employing each of the three linkages (<a href="https://en.wikipedia.org/wiki/Complete-linkage_clustering">complete</a>, <a href="https://en.wikipedia.org/wiki/Single-linkage_clustering">single</a>, and <a href="https://en.wikipedia.org/wiki/UPGMA">average</a>), since the choice of linkage affects the clustering (see Table 1 for an example).</p>
<p>For example:</p>
<table>
<thead>
<tr class="header">
<th align="left">Search query</th>
<th align="center">Single-linkage</th>
<th align="center">Complete-linkage</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">brtisth gas</td>
<td align="center">Cluster A</td>
<td align="center">Cluster A</td>
</tr>
<tr class="even">
<td align="left">brtisth gaz</td>
<td align="center">Cluster A</td>
<td align="center">Cluster A</td>
</tr>
<tr class="odd">
<td align="left">brtisth gazcomapny</td>
<td align="center">Cluster B</td>
<td align="center">Cluster A</td>
</tr>
<tr class="even">
<td align="left">fusion shell bg group</td>
<td align="center">Cluster C</td>
<td align="center">Cluster B</td>
</tr>
</tbody>
</table>
<p class="caption">
<strong>Table 1</strong>: Example of how choice of linkage affects clustering of queries from a real search session.
</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">overlapping_results &lt;-<span class="st"> </span>function(x) {
  if (<span class="kw">all</span>(<span class="kw">is.na</span>(x))) {
    <span class="kw">return</span>(<span class="kw">diag</span>(<span class="kw">length</span>(x)))
  }
  input &lt;-<span class="st"> </span><span class="kw">strsplit</span>(stringr::<span class="kw">str_replace_all</span>(x, <span class="st">&quot;[</span><span class="ch">\\</span><span class="st">[</span><span class="ch">\\</span><span class="st">]]&quot;</span>, <span class="st">&quot;&quot;</span>), <span class="st">&quot;,&quot;</span>)
  output &lt;-<span class="st"> </span><span class="kw">vapply</span>(input, function(y) {
    temp &lt;-<span class="st"> </span><span class="kw">vapply</span>(input, function(z) { <span class="kw">length</span>(<span class="kw">intersect</span>(z, y)) }, 0L)
    <span class="co"># Normalize by diving by number of possible matches</span>
    <span class="co"># e.g. if two queries have two results each that are</span>
    <span class="co">#      exactly the same, that&#39;s worth more than if</span>
    <span class="co">#      two queries have 20 results each but have</span>
    <span class="co">#      only three in common</span>
    temp &lt;-<span class="st"> </span>temp/<span class="kw">pmin</span>(<span class="kw">rep</span>(<span class="kw">length</span>(y), <span class="kw">length</span>(input)), <span class="kw">vapply</span>(input, length, 0L))
    temp[<span class="kw">is.na</span>(x)] &lt;-<span class="st"> </span>0L
    <span class="kw">return</span>(temp)
  }, <span class="kw">rep</span>(<span class="fl">0.0</span>, <span class="kw">length</span>(input)))
  <span class="kw">diag</span>(output) &lt;-<span class="st"> </span>1L
  <span class="kw">return</span>(output)
}

cluster_queries &lt;-<span class="st"> </span>function(queries, results, <span class="dt">linkage =</span> <span class="kw">c</span>(<span class="st">&quot;complete&quot;</span>, <span class="st">&quot;single&quot;</span>, <span class="st">&quot;average&quot;</span>), <span class="dt">threshold =</span> <span class="ot">NULL</span>, <span class="dt">debug =</span> <span class="ot">FALSE</span>) {
  if (<span class="kw">length</span>(queries) &lt;<span class="st"> </span><span class="dv">2</span>) {
    <span class="kw">return</span>(<span class="dv">1</span>)
  }
  input &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">query =</span> queries, <span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span>)
  x &lt;-<span class="st"> </span><span class="kw">do.call</span>(rbind, <span class="kw">lapply</span>(input$query, function(x) {
    <span class="co"># Compute for each x in input$query the normalized edit distance from x to input$query:</span>
    normalized_distances &lt;-<span class="st"> </span><span class="kw">adist</span>(<span class="kw">tolower</span>(x), <span class="kw">tolower</span>(input$query), <span class="dt">fixed =</span> <span class="ot">TRUE</span>)/<span class="kw">pmax</span>(<span class="kw">nchar</span>(x), <span class="kw">nchar</span>(input$query))
    <span class="co"># Return:</span>
    <span class="kw">return</span>(normalized_distances)
  }))
  <span class="co"># Decrease distance of queries that share results:</span>
  overlaps &lt;-<span class="st"> </span><span class="kw">overlapping_results</span>(results)
  x &lt;-<span class="st"> </span>x *<span class="st"> </span>(<span class="dv">10</span>^(-overlaps))
  <span class="co"># ^ if two queries have the exact same results, we make the new</span>
  <span class="co">#   edit distance 0.1 of what their original edit distance is</span>
  <span class="co"># Create distance object:</span>
  y &lt;-<span class="st"> </span>x[<span class="kw">lower.tri</span>(x, <span class="dt">diag =</span> <span class="ot">FALSE</span>)]
  d &lt;-<span class="st"> </span><span class="kw">structure</span>(
    y, <span class="dt">Size =</span> <span class="kw">length</span>(queries), <span class="dt">Labels =</span> queries, <span class="dt">Diag =</span> <span class="ot">FALSE</span>, <span class="dt">Upper =</span> <span class="ot">FALSE</span>,
    <span class="dt">method =</span> <span class="st">&quot;levenshtein&quot;</span>, <span class="dt">class =</span> <span class="st">&quot;dist&quot;</span>, <span class="dt">call =</span> <span class="kw">match.call</span>()
  )
  clustering_tree &lt;-<span class="st"> </span><span class="kw">hclust</span>(d, <span class="dt">method =</span> linkage[<span class="dv">1</span>])
  <span class="co"># When using average linkage, we may end up with funky trees</span>
  <span class="co">#   that cannot be properly cut. So this logic helps against</span>
  <span class="co">#   errors and yieds NAs instead.</span>
  clusters &lt;-<span class="st"> </span><span class="kw">tryCatch</span>(
    <span class="kw">cutree</span>(clustering_tree, <span class="dt">h =</span> threshold),
    <span class="dt">error =</span> function(e) { <span class="kw">return</span>(<span class="ot">NA</span>) })
  if (<span class="kw">all</span>(<span class="kw">is.na</span>(clusters))) {
    clusters &lt;-<span class="st"> </span><span class="kw">rep</span>(clusters, <span class="kw">nrow</span>(input))
    <span class="kw">names</span>(clusters) &lt;-<span class="st"> </span>input$query
  }
  output &lt;-<span class="st"> </span><span class="kw">left_join</span>(
    input,
    <span class="kw">data.frame</span>(<span class="dt">query =</span> <span class="kw">names</span>(clusters),
               <span class="dt">cluster =</span> <span class="kw">as.numeric</span>(clusters),
               <span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span>),
    <span class="dt">by =</span> <span class="st">&quot;query&quot;</span>)
  if (debug) {
    <span class="kw">return</span>(
      <span class="kw">list</span>(
        <span class="dt">original_distances =</span> x /<span class="st"> </span>(<span class="dv">10</span>^(-overlaps)),
        <span class="dt">overlaps =</span> overlaps,
        <span class="dt">modified_distances =</span> d,
        <span class="dt">output =</span> output,
        <span class="dt">hc =</span> clustering_tree
      )
    )
  }
  <span class="kw">return</span>(output$cluster)
}</code></pre></div>
</div>
<div id="paulscore-definition" class="section level3">
<h3>PaulScore Definition</h3>
<p>PaulScore<sup><a href="#ref-1">[1]</a></sup> is a measure of search results’ relevancy which takes into account the position of the clicked results, and is computed via the following steps:</p>
<ol>
<li>Pick scoring factor <span class="math inline">\(0 &lt; F &lt; 1\)</span> (larger values of <span class="math inline">\(F\)</span> increase the weight of clicks on lower-ranked results).</li>
<li>For <span class="math inline">\(i\)</span>-th search session <span class="math inline">\(S_i\)</span> <span class="math inline">\((i = 1, \ldots, n)\)</span> containing <span class="math inline">\(m\)</span> queries <span class="math inline">\(Q_1, \ldots, Q_m\)</span> and search result sets <span class="math inline">\(\mathbf{R}_1, \ldots, \mathbf{R}_m\)</span>:
<ol>
<li>For each <span class="math inline">\(j\)</span>-th search query <span class="math inline">\(Q_j\)</span> with result set <span class="math inline">\(\mathbf{R}_j\)</span>, let <span class="math inline">\(\nu_j\)</span> be the query score: <span class="math display">\[\nu_j = \sum_{k~\in~\{\text{0-based positions of clicked results in}~\mathbf{R}_j\}} F^k.\]</span></li>
<li>Let user’s average query score <span class="math inline">\(\bar{\nu}_{(i)}\)</span> be <span class="math display">\[\bar{\nu}_{(i)} = \frac{1}{m} \sum_{j = 1}^m \nu_j.\]</span></li>
</ol></li>
<li>Then the PaulScore is the average of all users’ average query scores: <span class="math display">\[\text{PaulScore}(F)~=~\frac{1}{n} \sum_{i = 1}^n \bar{\nu}_{(i)}.\]</span></li>
</ol>
<p>We can calculate the confidence interval of PaulScore<span class="math inline">\((F)\)</span> by approximating its distribution via <a href="https://en.wikipedia.org/wiki/Bootstrapping_(statistics)">boostrapping</a>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># PaulScore Calculation</span>
query_score &lt;-<span class="st"> </span>function(positions, F) {
   if (<span class="kw">length</span>(positions) ==<span class="st"> </span><span class="dv">1</span> ||<span class="st"> </span><span class="kw">all</span>(<span class="kw">is.na</span>(positions))) {
    <span class="co"># no clicks were made</span>
    <span class="kw">return</span>(<span class="dv">0</span>)
   } else {
     positions &lt;-<span class="st"> </span>positions[!<span class="kw">is.na</span>(positions)] <span class="co"># when operating on &#39;events&#39; dataset, SERP events won&#39;t have positions</span>
  <span class="kw">return</span>(<span class="kw">sum</span>(F^positions))
   }
}
<span class="co"># Bootstrapping</span>
bootstrap_mean &lt;-<span class="st"> </span>function(x, m, <span class="dt">seed =</span> <span class="ot">NULL</span>) {
  if (!<span class="kw">is.null</span>(seed)) {
    <span class="kw">set.seed</span>(seed)
  }
  n &lt;-<span class="st"> </span><span class="kw">length</span>(x)
  <span class="kw">return</span>(<span class="kw">replicate</span>(m, <span class="kw">mean</span>(x[<span class="kw">sample.int</span>(n, n, <span class="dt">replace =</span> <span class="ot">TRUE</span>)])))
}</code></pre></div>
</div>
</div>
<div id="results" class="section level2">
<h2>Results</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Import events fetched from MySQL</span>
<span class="kw">load</span>(<span class="kw">path</span>(<span class="st">&quot;data/ab-test_bm25.RData&quot;</span>))
events$test_group &lt;-<span class="st"> </span><span class="kw">factor</span>(
  events$test_group,
  <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">&quot;bm25:control&quot;</span>, <span class="st">&quot;bm25:allfield&quot;</span>, <span class="st">&quot;bm25:inclinks&quot;</span>, <span class="st">&quot;bm25:inclinks_pv&quot;</span>, <span class="st">&quot;bm25:inclinks_pv_rev&quot;</span>),
  <span class="dt">labels =</span> <span class="kw">c</span>(<span class="st">&quot;Control Group (tf–idf)&quot;</span>, <span class="st">&quot;Same query builder as control group but using BM25 as similarity function&quot;</span>, <span class="st">&quot;Using per-field query building with incoming links as QIF&quot;</span>, <span class="st">&quot;Using per-field query builder with incoming links and pageviews as QIFs&quot;</span>, <span class="st">&quot;Track typos in first 2 characters&quot;</span>))
cirrus &lt;-<span class="st"> </span>readr::<span class="kw">read_tsv</span>(<span class="kw">path</span>(<span class="st">&quot;data/ab-test_bm25_cirrus-results.tsv.gz&quot;</span>), <span class="dt">col_types =</span> <span class="st">&quot;ccc&quot;</span>)
events &lt;-<span class="st"> </span><span class="kw">left_join</span>(events, cirrus, <span class="dt">by =</span> <span class="kw">c</span>(<span class="st">&quot;event_id&quot;</span>, <span class="st">&quot;page_id&quot;</span>))
<span class="kw">rm</span>(cirrus)</code></pre></div>
<p>The test was deployed on September 1st and ran for 10 days, collecting a total of 119.6K events from 36.2K unique sessions. See Table 2 for counts broken down by test group.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">events_summary &lt;-<span class="st"> </span>events %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(<span class="st">`</span><span class="dt">Test group</span><span class="st">`</span> =<span class="st"> </span>test_group) %&gt;%
<span class="st">  </span><span class="kw">summarize</span>(<span class="st">`</span><span class="dt">Search sessions</span><span class="st">`</span> =<span class="st"> </span><span class="kw">length</span>(<span class="kw">unique</span>(search_id)), <span class="st">`</span><span class="dt">Events recorded</span><span class="st">`</span> =<span class="st"> </span><span class="kw">n</span>()) %&gt;%
<span class="st">  </span>{
    <span class="kw">rbind</span>(., <span class="kw">tibble</span>(
      <span class="st">`</span><span class="dt">Test group</span><span class="st">`</span> =<span class="st"> &quot;Total&quot;</span>,
      <span class="st">`</span><span class="dt">Search sessions</span><span class="st">`</span> =<span class="st"> </span><span class="kw">sum</span>(.$<span class="st">`</span><span class="dt">Search sessions</span><span class="st">`</span>),
      <span class="st">`</span><span class="dt">Events recorded</span><span class="st">`</span> =<span class="st"> </span><span class="kw">sum</span>(.$<span class="st">`</span><span class="dt">Events recorded</span><span class="st">`</span>)
    ))
  } %&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="st">`</span><span class="dt">Search sessions</span><span class="st">`</span> =<span class="st"> </span><span class="kw">prettyNum</span>(<span class="st">`</span><span class="dt">Search sessions</span><span class="st">`</span>, <span class="dt">big.mark =</span> <span class="st">&quot;,&quot;</span>),
         <span class="st">`</span><span class="dt">Events recorded</span><span class="st">`</span> =<span class="st"> </span><span class="kw">prettyNum</span>(<span class="st">`</span><span class="dt">Events recorded</span><span class="st">`</span>, <span class="dt">big.mark =</span> <span class="st">&quot;,&quot;</span>))
events_summary$<span class="st">`</span><span class="dt">Test group</span><span class="st">`</span> &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="st">&quot;&lt;span class=&#39;test-group-&quot;</span>, <span class="dv">1</span>:<span class="kw">nrow</span>(events_summary), <span class="st">&quot;&#39;&gt;&quot;</span>, events_summary$<span class="st">`</span><span class="dt">Test group</span><span class="st">`</span>, <span class="st">&quot;&lt;/span&gt;&quot;</span>)
knitr::<span class="kw">kable</span>(events_summary, <span class="dt">format =</span> <span class="st">&quot;markdown&quot;</span>, <span class="dt">align =</span> <span class="kw">c</span>(<span class="st">&quot;l&quot;</span>, <span class="st">&quot;r&quot;</span>, <span class="st">&quot;r&quot;</span>))</code></pre></div>
<table style="width:100%;">
<colgroup>
<col width="76%" />
<col width="11%" />
<col width="11%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Test group</th>
<th align="right">Search sessions</th>
<th align="right">Events recorded</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><span class="test-group-1">Control Group (tf–idf)</span></td>
<td align="right">7,297</td>
<td align="right">23,484</td>
</tr>
<tr class="even">
<td align="left"><span class="test-group-2">Same query builder as control group but using BM25 as similarity function</span></td>
<td align="right">7,133</td>
<td align="right">22,908</td>
</tr>
<tr class="odd">
<td align="left"><span class="test-group-3">Using per-field query building with incoming links as QIF</span></td>
<td align="right">7,330</td>
<td align="right">24,799</td>
</tr>
<tr class="even">
<td align="left"><span class="test-group-4">Using per-field query builder with incoming links and pageviews as QIFs</span></td>
<td align="right">7,235</td>
<td align="right">23,557</td>
</tr>
<tr class="odd">
<td align="left"><span class="test-group-5">Track typos in first 2 characters</span></td>
<td align="right">7,161</td>
<td align="right">24,868</td>
</tr>
<tr class="even">
<td align="left"><span class="test-group-6">Total</span></td>
<td align="right">36,156</td>
<td align="right">119,616</td>
</tr>
</tbody>
</table>
<p class="caption">
<strong>Table 2</strong>: Counts of sessions anonymously tracked and events collected during the ten-day-long A/B test.
</p>
<div id="serp-de-duplication" class="section level3">
<h3>SERP De-duplication</h3>
<p>An issue we noticed with the event logging is that when the user goes to the next page of search results or clicks the Back button after visiting a search result, a new page ID is generated for the search results page. The page ID is how we connect click events to search result page events. There is currently a Phabricator ticket (<a href="https://phabricator.wikimedia.org/T146337">T146337</a>) for addressing these issues. For this analysis, we de-duplicated by connecting search engine results page (SERP) events that have the exact same search query, and then connected click events together based on the SERP connectivity.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Correct for when user uses pagination or uses back button to go back to SERP after visiting a result.</span>
<span class="co"># Start by assigning the same page_id to different SERPs that have exactly the same query:</span>
temp &lt;-<span class="st"> </span>events %&gt;%
<span class="st">  </span><span class="kw">filter</span>(action ==<span class="st"> &quot;SERP&quot;</span>) %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(session_id, search_id, query) %&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">new_page_id =</span> <span class="kw">min</span>(page_id)) %&gt;%
<span class="st">  </span>ungroup %&gt;%
<span class="st">  </span><span class="kw">select</span>(<span class="kw">c</span>(page_id, new_page_id)) %&gt;%
<span class="st">  </span>distinct
<span class="co"># We also need to do the same for associated click events:</span>
events &lt;-<span class="st"> </span><span class="kw">left_join</span>(events, temp, <span class="dt">by =</span> <span class="st">&quot;page_id&quot;</span>); <span class="kw">rm</span>(temp)
<span class="co"># Find out which SERPs are duplicated:</span>
temp &lt;-<span class="st"> </span>events %&gt;%
<span class="st">  </span><span class="kw">filter</span>(action ==<span class="st"> &quot;SERP&quot;</span>) %&gt;%
<span class="st">  </span><span class="kw">arrange</span>(new_page_id, ts) %&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">dupe =</span> <span class="kw">duplicated</span>(new_page_id, <span class="dt">fromLast =</span> <span class="ot">FALSE</span>)) %&gt;%
<span class="st">  </span><span class="kw">select</span>(<span class="kw">c</span>(event_id, dupe))
events &lt;-<span class="st"> </span><span class="kw">left_join</span>(events, temp, <span class="dt">by =</span> <span class="st">&quot;event_id&quot;</span>); <span class="kw">rm</span>(temp)
events$dupe[events$action ==<span class="st"> &quot;click&quot;</span>] &lt;-<span class="st"> </span><span class="ot">FALSE</span>
<span class="co"># Remove duplicate SERPs and re-sort:</span>
events &lt;-<span class="st"> </span>events[!events$dupe &amp;<span class="st"> </span>!<span class="kw">is.na</span>(events$new_page_id), ] %&gt;%
<span class="st">  </span><span class="kw">select</span>(-<span class="kw">c</span>(page_id, dupe)) %&gt;%
<span class="st">  </span><span class="kw">rename</span>(<span class="dt">page_id =</span> new_page_id) %&gt;%
<span class="st">  </span><span class="kw">arrange</span>(date, session_id, search_id, page_id, <span class="kw">desc</span>(action), ts)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Summarize on a page-by-page basis:</span>
searches &lt;-<span class="st"> </span>events %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(<span class="st">`</span><span class="dt">test group</span><span class="st">`</span> =<span class="st"> </span>test_group, session_id, search_id, page_id) %&gt;%
<span class="st">  </span><span class="kw">filter</span>(<span class="st">&quot;SERP&quot;</span> %in%<span class="st"> </span>action) %&gt;%<span class="st"> </span><span class="co"># filter out searches where we have clicks but not SERP events</span>
<span class="st">  </span><span class="kw">summarize</span>(<span class="dt">ts =</span> ts[<span class="dv">1</span>], <span class="dt">query =</span> query[<span class="dv">1</span>],
            <span class="dt">results =</span> <span class="kw">ifelse</span>(n_results_returned[<span class="dv">1</span>] &gt;<span class="st"> </span><span class="dv">0</span>, <span class="st">&quot;some&quot;</span>, <span class="st">&quot;zero&quot;</span>),
            <span class="dt">clickthrough =</span> <span class="st">&quot;click&quot;</span> %in%<span class="st"> </span>action,
            <span class="st">`</span><span class="dt">first clicked result&#39;s position</span><span class="st">`</span> =<span class="st"> </span><span class="kw">ifelse</span>(clickthrough, position_clicked[<span class="dv">2</span>], <span class="ot">NA</span>),
            <span class="st">`</span><span class="dt">result page IDs</span><span class="st">`</span> =<span class="st"> </span>result_pids[<span class="dv">1</span>],
            <span class="st">`</span><span class="dt">Query score (F=0.1)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">query_score</span>(position_clicked, <span class="fl">0.1</span>),
            <span class="st">`</span><span class="dt">Query score (F=0.5)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">query_score</span>(position_clicked, <span class="fl">0.5</span>),
            <span class="st">`</span><span class="dt">Query score (F=0.9)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">query_score</span>(position_clicked, <span class="fl">0.9</span>)) %&gt;%
<span class="st">  </span><span class="kw">arrange</span>(ts)
<span class="co"># Cluster queries</span>
safe_clust &lt;-<span class="st"> </span>function(search_id, page_ids, queries, results, threshold, linkage) {
  clusters &lt;-<span class="st"> </span><span class="kw">cluster_queries</span>(queries, results, linkage, threshold)
  if (<span class="kw">length</span>(clusters) !=<span class="st"> </span><span class="kw">length</span>(page_ids)) {
    <span class="kw">stop</span>(<span class="st">&quot;Number of cluster labels does not match number of searches for search session &quot;</span>, <span class="kw">unlist</span>(search_id)[<span class="dv">1</span>])
  } else {
    <span class="kw">return</span>(clusters)
  }
}</code></pre></div>
<p>After de-duplicating, we collapsed 101.1K (SERP and click) events into 70K searches.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">searches &lt;-<span class="st"> </span>searches %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(<span class="st">`</span><span class="dt">test group</span><span class="st">`</span>, session_id, search_id) %&gt;%
<span class="st">  </span><span class="kw">mutate</span>(
    <span class="dt">cluster_single =</span> <span class="kw">safe_clust</span>(search_id, page_id, query, <span class="st">`</span><span class="dt">result page IDs</span><span class="st">`</span>, <span class="fl">0.301</span>, <span class="st">&quot;single&quot;</span>),
    <span class="dt">cluster_average =</span> <span class="kw">safe_clust</span>(search_id, page_id, query, <span class="st">`</span><span class="dt">result page IDs</span><span class="st">`</span>, <span class="fl">0.433</span>, <span class="st">&quot;average&quot;</span>),
    <span class="dt">cluster_complete =</span> <span class="kw">safe_clust</span>(search_id, page_id, query, <span class="st">`</span><span class="dt">result page IDs</span><span class="st">`</span>, <span class="fl">0.45</span>, <span class="st">&quot;complete&quot;</span>)
  )</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">most_common &lt;-<span class="st"> </span>function(x) {
  if (<span class="kw">all</span>(<span class="kw">is.na</span>(x))) {
    <span class="kw">return</span>(<span class="kw">as.character</span>(<span class="ot">NA</span>))
  } else {
     <span class="kw">return</span>(<span class="kw">names</span>(<span class="kw">sort</span>(<span class="kw">table</span>(x), <span class="dt">decreasing =</span> <span class="ot">TRUE</span>))[<span class="dv">1</span>])
  }
}

summarize_reformulations &lt;-<span class="st"> </span>function(grouped_data) {
  <span class="kw">return</span>({
    grouped_data %&gt;%
<span class="st">      </span><span class="co"># Count number of similar searches made in a single search session</span>
<span class="st">      </span><span class="co"># (multiple search sessions per MW session allowed)</span>
<span class="st">      </span><span class="kw">summarize</span>(
        <span class="dt">reformulations =</span> <span class="kw">n</span>() -<span class="st"> </span><span class="dv">1</span>,
        <span class="dt">clickthrough =</span> <span class="kw">any</span>(clickthrough),
        <span class="dt">results =</span> <span class="kw">ifelse</span>(<span class="st">&quot;some&quot;</span> %in%<span class="st"> </span>results, <span class="st">&quot;some&quot;</span>, <span class="st">&quot;zero&quot;</span>),
        <span class="st">`</span><span class="dt">most popular position clicked first</span><span class="st">`</span> =<span class="st"> </span><span class="kw">most_common</span>(<span class="st">`</span><span class="dt">first clicked result&#39;s position</span><span class="st">`</span>),
        <span class="st">`</span><span class="dt">Cluster score (F=0.1)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">mean</span>(<span class="st">`</span><span class="dt">Query score (F=0.1)</span><span class="st">`</span>, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>),
        <span class="st">`</span><span class="dt">Cluster score (F=0.5)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">mean</span>(<span class="st">`</span><span class="dt">Query score (F=0.5)</span><span class="st">`</span>, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>),
        <span class="st">`</span><span class="dt">Cluster score (F=0.9)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">mean</span>(<span class="st">`</span><span class="dt">Query score (F=0.9)</span><span class="st">`</span>, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
      ) %&gt;%
<span class="st">      </span>ungroup
  })
}

<span class="kw">set.seed</span>(<span class="dv">0</span>) <span class="co"># for reproducibility</span>
query_reformulations_single &lt;-<span class="st"> </span>searches %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(<span class="st">`</span><span class="dt">test group</span><span class="st">`</span>, session_id, search_id, <span class="dt">cluster =</span> cluster_single) %&gt;%
<span class="st">  </span>summarize_reformulations
query_reformulations_complete &lt;-<span class="st"> </span>searches %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(<span class="st">`</span><span class="dt">test group</span><span class="st">`</span>, session_id, search_id, <span class="dt">cluster =</span> cluster_complete) %&gt;%
<span class="st">  </span>summarize_reformulations
query_reformulations_average &lt;-<span class="st"> </span>searches %&gt;%
<span class="st">  </span>ungroup %&gt;%
<span class="st">  </span><span class="kw">filter</span>(!<span class="kw">is.na</span>(cluster_average)) %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(<span class="st">`</span><span class="dt">test group</span><span class="st">`</span>, session_id, search_id, <span class="dt">cluster =</span> cluster_average) %&gt;%
<span class="st">  </span>summarize_reformulations
query_reformulations &lt;-<span class="st"> </span><span class="kw">bind_rows</span>(
  <span class="st">&quot;Queries grouped via average linkage&quot;</span> =<span class="st"> </span>query_reformulations_average,
  <span class="st">&quot;Queries grouped via complete linkage&quot;</span> =<span class="st"> </span>query_reformulations_complete,
  <span class="st">&quot;Queries grouped via single linkage&quot;</span> =<span class="st"> </span>query_reformulations_single,
  <span class="dt">.id =</span> <span class="st">&quot;linkage&quot;</span>)
<span class="kw">rm</span>(query_reformulations_average, query_reformulations_complete, query_reformulations_single)</code></pre></div>
</div>
<div id="query-reformulation" class="section level3">
<h3>Query Reformulation</h3>
<p>As mentioned in the Methods section, we used hierarchical clustering to group similar searches together. That is, if the edit distance between two search queries is small enough and the search result sets overlap, those searches are probably the user reformulating their query. In Figures 1 and 2, we see proportions of searches that were reformulations, according to three different ways to group searches. The <span class="test-group-2">second group</span> (“<span class="test-group-2">same query builder as control group but using BM25</span>”) had the highest proportion of searches where the user reformulated their query at least once, and this difference is statistically significant. According to clustering via single linkage, <span class="test-group-5">the last group (BM25 with incoming links and tracking typos)</span> had the lowest proportion of query reformulations.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Calculate proportions of searches with 0, 1, 2, 3+ query reformulations</span>
query_reformulations %&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="st">`</span><span class="dt">query reformulations</span><span class="st">`</span> =<span class="st"> </span>forcats::<span class="kw">fct_lump</span>(<span class="kw">factor</span>(reformulations), <span class="dv">3</span>, <span class="dt">other_level =</span> <span class="st">&quot;3+&quot;</span>)) %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(linkage, <span class="st">`</span><span class="dt">test group</span><span class="st">`</span>, <span class="st">`</span><span class="dt">query reformulations</span><span class="st">`</span>) %&gt;%
<span class="st">  </span>tally %&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">proportion =</span> n/<span class="kw">sum</span>(n)) %&gt;%
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> <span class="st">`</span><span class="dt">query reformulations</span><span class="st">`</span>, <span class="dt">y =</span> proportion, <span class="dt">fill =</span> <span class="st">`</span><span class="dt">test group</span><span class="st">`</span>)) +
<span class="st">  </span><span class="kw">geom_bar</span>(<span class="dt">stat =</span> <span class="st">&quot;identity&quot;</span>, <span class="dt">position =</span> <span class="st">&quot;dodge&quot;</span>) +
<span class="st">  </span><span class="kw">scale_y_continuous</span>(<span class="dt">labels =</span> scales::<span class="kw">percent_format</span>()) +
<span class="st">  </span><span class="kw">scale_fill_brewer</span>(<span class="st">&quot;Test Group&quot;</span>, <span class="dt">palette =</span> <span class="st">&quot;Set1&quot;</span>, <span class="dt">guide =</span> <span class="kw">guide_legend</span>(<span class="dt">ncol =</span> <span class="dv">2</span>)) +
<span class="st">  </span><span class="kw">facet_wrap</span>(~<span class="st"> </span>linkage, <span class="dt">ncol =</span> <span class="dv">3</span>) +
<span class="st">  </span><span class="kw">labs</span>(<span class="dt">y =</span> <span class="st">&quot;Proportion of searches&quot;</span>, <span class="dt">x =</span> <span class="st">&quot;Approximate number of query reformulations per search session&quot;</span>,
       <span class="dt">title =</span> <span class="st">&quot;Number of query reformulations by test group and linkage&quot;</span>,
       <span class="dt">subtitle =</span> <span class="st">&quot;Queries were grouped via hierarchical clustering using average/complete/single linkage and edit distance adjusted by search results in common&quot;</span>) +
<span class="st">  </span><span class="kw">theme_minimal</span>(<span class="dt">base_family =</span> <span class="st">&quot;Lato&quot;</span>) +
<span class="st">  </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">&quot;bottom&quot;</span>,
        <span class="dt">strip.background =</span> <span class="kw">element_rect</span>(<span class="dt">fill =</span> <span class="st">&quot;gray90&quot;</span>),
        <span class="dt">panel.border =</span> <span class="kw">element_rect</span>(<span class="dt">color =</span> <span class="st">&quot;gray30&quot;</span>, <span class="dt">fill =</span> <span class="ot">NA</span>))</code></pre></div>
<div class="figure">
<img src="index_files/figure-html/query_reformulations_counts_eda-1.png" alt="Figure 1: Proportions of searches with 0, 1, 2, and 3+ query reformulations." />
<p class="caption"><strong>Figure 1</strong>: Proportions of searches with 0, 1, 2, and 3+ query reformulations.</p>
</div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Calculate proportion of searches where user reformulated their query</span>
reformulation_counts &lt;-<span class="st"> </span>query_reformulations %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(linkage, <span class="st">`</span><span class="dt">test group</span><span class="st">`</span>) %&gt;%
<span class="st">  </span><span class="kw">summarize</span>(<span class="st">`</span><span class="dt">searches with query reformulations</span><span class="st">`</span> =<span class="st"> </span><span class="kw">sum</span>(reformulations &gt;<span class="st"> </span><span class="dv">0</span>),
            <span class="dt">searches =</span> <span class="kw">n</span>(),
            <span class="dt">proportion =</span> <span class="st">`</span><span class="dt">searches with query reformulations</span><span class="st">`</span>/searches) %&gt;%
<span class="st">  </span>ungroup
reformulation_counts &lt;-<span class="st"> </span><span class="kw">cbind</span>(
  reformulation_counts,
  <span class="kw">as.data.frame</span>(
    binom:::<span class="kw">binom.bayes</span>(
      reformulation_counts$<span class="st">`</span><span class="dt">searches with query reformulations</span><span class="st">`</span>,
      <span class="dt">n =</span> reformulation_counts$searches)[, <span class="kw">c</span>(<span class="st">&quot;mean&quot;</span>, <span class="st">&quot;lower&quot;</span>, <span class="st">&quot;upper&quot;</span>)]
  )
)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">reformulation_counts %&gt;%
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">y =</span> mean, <span class="dt">color =</span> <span class="st">`</span><span class="dt">test group</span><span class="st">`</span>)) +
<span class="st">  </span><span class="kw">geom_hline</span>(<span class="kw">aes</span>(<span class="dt">yintercept =</span> mean), <span class="dt">linetype =</span> <span class="st">&quot;dashed&quot;</span>, <span class="dt">color =</span> RColorBrewer::<span class="kw">brewer.pal</span>(<span class="dv">3</span>, <span class="st">&quot;Set1&quot;</span>)[<span class="dv">1</span>],
             <span class="dt">data =</span> <span class="kw">filter</span>(reformulation_counts, <span class="st">`</span><span class="dt">test group</span><span class="st">`</span> ==<span class="st"> &quot;Control Group (tf–idf)&quot;</span>)) +
<span class="st">  </span><span class="kw">geom_pointrange</span>(<span class="kw">aes</span>(<span class="dt">ymin =</span> lower, <span class="dt">ymax =</span> upper), <span class="dt">position =</span> <span class="kw">position_dodge</span>(<span class="dt">width =</span> <span class="dv">1</span>)) +
<span class="st">  </span><span class="kw">scale_y_continuous</span>(<span class="dt">labels =</span> scales::<span class="kw">percent_format</span>(),
                     <span class="dt">breaks =</span> <span class="kw">seq</span>(.<span class="dv">10</span>, .<span class="dv">24</span>, <span class="fl">0.01</span>),
                     <span class="dt">minor_breaks =</span> <span class="kw">seq</span>(.<span class="dv">10</span>, .<span class="dv">24</span>, <span class="fl">0.005</span>),
                     <span class="dt">expand =</span> <span class="kw">c</span>(<span class="fl">0.01</span>, <span class="fl">0.01</span>)) +
<span class="st">  </span><span class="kw">scale_color_brewer</span>(<span class="st">&quot;Test Group&quot;</span>, <span class="dt">palette =</span> <span class="st">&quot;Set1&quot;</span>, <span class="dt">guide =</span> <span class="kw">guide_legend</span>(<span class="dt">ncol =</span> <span class="dv">2</span>)) +
<span class="st">  </span><span class="kw">facet_wrap</span>(~<span class="st"> </span>linkage, <span class="dt">ncol =</span> <span class="dv">3</span>) +
<span class="st">  </span><span class="kw">geom_text</span>(<span class="kw">aes</span>(<span class="dt">label =</span> <span class="kw">sprintf</span>(<span class="st">&quot;%.1f%%&quot;</span>, <span class="dv">100</span> *<span class="st"> </span>proportion), <span class="dt">y =</span> upper +<span class="st"> </span><span class="fl">0.0025</span>, <span class="dt">vjust =</span> <span class="st">&quot;bottom&quot;</span>),
            <span class="dt">position =</span> <span class="kw">position_dodge</span>(<span class="dt">width =</span> <span class="dv">1</span>)) +
<span class="st">  </span><span class="kw">labs</span>(<span class="dt">y =</span> <span class="st">&quot;% of searches with query reformulations&quot;</span>, <span class="dt">x =</span> <span class="ot">NULL</span>,
       <span class="dt">title =</span> <span class="st">&quot;Searches with reformulated queries by test group (and linkage)&quot;</span>,
       <span class="dt">subtitle =</span> <span class="st">&quot;Queries were grouped via hierarchical clustering using average/complete/single linkage and edit distance adjusted by search results in common&quot;</span>) +
<span class="st">  </span><span class="kw">theme_minimal</span>(<span class="dt">base_family =</span> <span class="st">&quot;Lato&quot;</span>) +
<span class="st">  </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">&quot;bottom&quot;</span>,
        <span class="dt">panel.grid.major.x =</span> <span class="kw">element_blank</span>(),
        <span class="dt">panel.grid.minor.x =</span> <span class="kw">element_blank</span>(),
        <span class="dt">axis.ticks.x =</span> <span class="kw">element_blank</span>(),
        <span class="dt">axis.text.x =</span> <span class="kw">element_blank</span>(),
        <span class="dt">strip.background =</span> <span class="kw">element_rect</span>(<span class="dt">fill =</span> <span class="st">&quot;gray90&quot;</span>),
        <span class="dt">panel.border =</span> <span class="kw">element_rect</span>(<span class="dt">color =</span> <span class="st">&quot;gray30&quot;</span>, <span class="dt">fill =</span> <span class="ot">NA</span>))</code></pre></div>
<div class="figure">
<img src="index_files/figure-html/query_reformulations_prop_eda-1.png" alt="Figure 2: Proportions of searches where user reformulated their query." />
<p class="caption"><strong>Figure 2</strong>: Proportions of searches where user reformulated their query.</p>
</div>
</div>
<div id="zero-results-rate" class="section level3">
<h3>Zero Results Rate</h3>
<p>In Figure 3, we see that zero results rate (ZRR) was not so different between the groups. The <span class="test-group-5">test group where we tracked typos in first two characters</span> had a significantly lower ZRR, but perhaps at the cost of relevance and engagement with the results (see Figure 5).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">zrr_pages &lt;-<span class="st"> </span>searches %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(<span class="st">`</span><span class="dt">test group</span><span class="st">`</span>, results) %&gt;%
<span class="st">  </span>tally %&gt;%
<span class="st">  </span><span class="kw">spread</span>(results, n) %&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="st">`</span><span class="dt">zero results rate</span><span class="st">`</span> =<span class="st"> </span>zero/(some +<span class="st"> </span>zero)) %&gt;%
<span class="st">  </span>ungroup
zrr_pages &lt;-<span class="st"> </span><span class="kw">cbind</span>(zrr_pages, <span class="kw">as.data.frame</span>(binom:::<span class="kw">binom.bayes</span>(zrr_pages$zero, <span class="dt">n =</span> zrr_pages$some +<span class="st"> </span>zrr_pages$zero)[, <span class="kw">c</span>(<span class="st">&quot;mean&quot;</span>, <span class="st">&quot;lower&quot;</span>, <span class="st">&quot;upper&quot;</span>)]))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">zrr_pages %&gt;%
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> <span class="st">`</span><span class="dt">test group</span><span class="st">`</span>, <span class="dt">y =</span> <span class="st">`</span><span class="dt">mean</span><span class="st">`</span>, <span class="dt">color =</span> <span class="st">`</span><span class="dt">test group</span><span class="st">`</span>)) +
<span class="st">  </span><span class="kw">geom_hline</span>(
    <span class="dt">yintercept =</span> zrr_pages$<span class="st">`</span><span class="dt">mean</span><span class="st">`</span>[zrr_pages$<span class="st">`</span><span class="dt">test group</span><span class="st">`</span> ==<span class="st"> &quot;Control Group (tf–idf)&quot;</span>],
    <span class="dt">linetype =</span> <span class="st">&quot;dashed&quot;</span>, <span class="dt">color =</span> <span class="st">&quot;gray50&quot;</span>) +
<span class="st">  </span><span class="kw">geom_pointrange</span>(<span class="kw">aes</span>(<span class="dt">ymin =</span> lower, <span class="dt">ymax =</span> upper)) +
<span class="st">  </span><span class="kw">scale_x_discrete</span>(<span class="dt">limits =</span> <span class="kw">rev</span>(<span class="kw">levels</span>(events$test_group))) +
<span class="st">  </span><span class="kw">scale_y_continuous</span>(<span class="dt">labels =</span> scales::<span class="kw">percent_format</span>()) +
<span class="st">  </span><span class="kw">scale_color_brewer</span>(<span class="st">&quot;Test Group&quot;</span>, <span class="dt">palette =</span> <span class="st">&quot;Set1&quot;</span>, <span class="dt">guide =</span> <span class="ot">FALSE</span>) +
<span class="st">  </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="ot">NULL</span>, <span class="dt">y =</span> <span class="st">&quot;Zero Results Rate&quot;</span>,
       <span class="dt">title =</span> <span class="st">&quot;Proportion of searches that did not yield any results, by test group&quot;</span>,
       <span class="dt">subtitle =</span> <span class="st">&quot;With 95% credible intervals. Dashed line represents the baseline (ZRR of the control group).&quot;</span>) +
<span class="st">  </span><span class="kw">geom_text</span>(<span class="kw">aes</span>(<span class="dt">label =</span> <span class="kw">sprintf</span>(<span class="st">&quot;%.2f%%&quot;</span>, <span class="dv">100</span> *<span class="st"> `</span><span class="dt">zero results rate</span><span class="st">`</span>),
                <span class="dt">vjust =</span> <span class="st">&quot;bottom&quot;</span>, <span class="dt">hjust =</span> <span class="st">&quot;center&quot;</span>), <span class="dt">nudge_x =</span> <span class="fl">0.1</span>) +
<span class="st">  </span><span class="kw">coord_flip</span>() +
<span class="st">  </span><span class="kw">theme_minimal</span>(<span class="dt">base_family =</span> <span class="st">&quot;Lato&quot;</span>)</code></pre></div>
<div class="figure">
<img src="index_files/figure-html/zrr_eda-1.png" alt="Figure 3: Zero results rate is the proportion of searches in which the user received zero results." />
<p class="caption"><strong>Figure 3</strong>: Zero results rate is the proportion of searches in which the user received zero results.</p>
</div>
</div>
<div id="paulscore" class="section level3">
<h3>PaulScore</h3>
<p>In Figure 4, we see that the <span class="test-group-3">test groups that used BM25 with incoming links</span> and <span class="test-group-4">pageviews as query-independent factors</span> had higher PaulScores, which indicates that the results were more relevant.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">0</span>) <span class="co"># for reproducibility</span>
paulscores &lt;-<span class="st"> </span>searches %&gt;%
<span class="st">  </span>ungroup %&gt;%
<span class="st">  </span><span class="kw">select</span>(<span class="kw">c</span>(<span class="st">`</span><span class="dt">test group</span><span class="st">`</span>, <span class="st">`</span><span class="dt">Query score (F=0.1)</span><span class="st">`</span>, <span class="st">`</span><span class="dt">Query score (F=0.5)</span><span class="st">`</span>, <span class="st">`</span><span class="dt">Query score (F=0.9)</span><span class="st">`</span>)) %&gt;%
<span class="st">  </span><span class="kw">gather</span>(<span class="st">`</span><span class="dt">F value</span><span class="st">`</span>, <span class="st">`</span><span class="dt">Query score</span><span class="st">`</span>, -<span class="st">`</span><span class="dt">test group</span><span class="st">`</span>) %&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="st">`</span><span class="dt">F value</span><span class="st">`</span> =<span class="st"> </span><span class="kw">sub</span>(<span class="st">&quot;^Query score </span><span class="ch">\\</span><span class="st">(F=(0</span><span class="ch">\\</span><span class="st">.[159])</span><span class="ch">\\</span><span class="st">)$&quot;</span>, <span class="st">&quot;F = </span><span class="ch">\\</span><span class="st">1&quot;</span>, <span class="st">`</span><span class="dt">F value</span><span class="st">`</span>)) %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(<span class="st">`</span><span class="dt">test group</span><span class="st">`</span>, <span class="st">`</span><span class="dt">F value</span><span class="st">`</span>) %&gt;%
<span class="st">  </span><span class="kw">summarize</span>(
    <span class="dt">PaulScore =</span> <span class="kw">mean</span>(<span class="st">`</span><span class="dt">Query score</span><span class="st">`</span>),
    <span class="dt">Interval =</span> <span class="kw">paste0</span>(<span class="kw">quantile</span>(<span class="kw">bootstrap_mean</span>(<span class="st">`</span><span class="dt">Query score</span><span class="st">`</span>, <span class="dv">1000</span>), <span class="kw">c</span>(<span class="fl">0.025</span>, <span class="fl">0.975</span>)), <span class="dt">collapse =</span> <span class="st">&quot;,&quot;</span>)
  ) %&gt;%
<span class="st">  </span><span class="kw">extract</span>(Interval, <span class="dt">into =</span> <span class="kw">c</span>(<span class="st">&quot;Lower&quot;</span>, <span class="st">&quot;Upper&quot;</span>), <span class="dt">regex =</span> <span class="st">&quot;(.*),(.*)&quot;</span>, <span class="dt">convert =</span> <span class="ot">TRUE</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">paulscores %&gt;%
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> <span class="st">`</span><span class="dt">F value</span><span class="st">`</span>, <span class="dt">y =</span> PaulScore, <span class="dt">color =</span> <span class="st">`</span><span class="dt">test group</span><span class="st">`</span>)) +
<span class="st">  </span><span class="kw">geom_pointrange</span>(<span class="kw">aes</span>(<span class="dt">ymin =</span> Lower, <span class="dt">ymax =</span> Upper), <span class="dt">position =</span> <span class="kw">position_dodge</span>(<span class="dt">width =</span> <span class="fl">0.7</span>)) +
<span class="st">  </span><span class="kw">scale_color_brewer</span>(<span class="st">&quot;Test Group&quot;</span>, <span class="dt">palette =</span> <span class="st">&quot;Set1&quot;</span>, <span class="dt">guide =</span> <span class="kw">guide_legend</span>(<span class="dt">ncol =</span> <span class="dv">2</span>)) +
<span class="st">  </span><span class="kw">scale_y_continuous</span>(<span class="dt">limits =</span> <span class="kw">c</span>(<span class="fl">0.2</span>, <span class="fl">0.35</span>)) +
<span class="st">  </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="ot">NULL</span>, <span class="dt">y =</span> <span class="st">&quot;PaulScore(F)&quot;</span>,
       <span class="dt">title =</span> <span class="st">&quot;PaulScore(F) by test group and value of F&quot;</span>,
       <span class="dt">subtitle =</span> <span class="st">&quot;With bootstrapped 95% confidence intervals. Dashed line indicates baseline (control group) for comparing test groups.&quot;</span>) +
<span class="st">  </span><span class="kw">geom_text</span>(<span class="kw">aes</span>(<span class="dt">label =</span> <span class="kw">sprintf</span>(<span class="st">&quot;%.3f&quot;</span>, PaulScore), <span class="dt">y =</span> Upper +<span class="st"> </span><span class="fl">0.01</span>, <span class="dt">vjust =</span> <span class="st">&quot;bottom&quot;</span>),
            <span class="dt">position =</span> <span class="kw">position_dodge</span>(<span class="dt">width =</span> <span class="fl">0.7</span>)) +
<span class="st">  </span><span class="kw">theme_minimal</span>(<span class="dt">base_family =</span> <span class="st">&quot;Lato&quot;</span>) +
<span class="st">  </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">&quot;bottom&quot;</span>) +
<span class="st">  </span><span class="kw">annotate</span>(<span class="st">&quot;segment&quot;</span>,
           <span class="dt">x =</span> (<span class="dv">0</span>:<span class="dv">2</span>) +<span class="st"> </span><span class="fl">0.6</span>, <span class="dt">xend =</span> (<span class="dv">1</span>:<span class="dv">3</span>) +<span class="st"> </span><span class="fl">0.4</span>,
           <span class="dt">y =</span> paulscores$PaulScore[paulscores$<span class="st">`</span><span class="dt">test group</span><span class="st">`</span> ==<span class="st"> &quot;Control Group (tf–idf)&quot;</span>],
           <span class="dt">yend =</span> paulscores$PaulScore[paulscores$<span class="st">`</span><span class="dt">test group</span><span class="st">`</span> ==<span class="st"> &quot;Control Group (tf–idf)&quot;</span>],
           <span class="dt">color =</span> RColorBrewer::<span class="kw">brewer.pal</span>(<span class="dv">3</span>, <span class="st">&quot;Set1&quot;</span>)[<span class="dv">1</span>],
           <span class="dt">linetype =</span> <span class="st">&quot;dashed&quot;</span>)</code></pre></div>
<div class="figure">
<img src="index_files/figure-html/paulscores_eda-1.png" alt="Figure 4: Average per-group PaulScore for various values of F (0.1, 0.5, and 0.9) with bootstrapped confidence intervals." />
<p class="caption"><strong>Figure 4</strong>: Average per-group PaulScore for various values of F (0.1, 0.5, and 0.9) with bootstrapped confidence intervals.</p>
</div>
</div>
<div id="engagement" class="section level3">
<h3>Engagement</h3>
<p>In Figures 5 and 6, we see that the <span class="test-group-3">test groups that used BM25 with incoming links</span> and <span class="test-group-4">pageviews as query-independent factors</span> engaged with their search results more. The <span class="test-group-4">group whose search configuration included pageviews</span> had a much higher clickthrough rate than the control group when they did not reformulate their search query.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">engagement_overall &lt;-<span class="st"> </span>searches %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(<span class="st">`</span><span class="dt">test group</span><span class="st">`</span>) %&gt;%
<span class="st">  </span><span class="kw">summarize</span>(<span class="dt">clickthroughs =</span> <span class="kw">sum</span>(clickthrough &gt;<span class="st"> </span><span class="dv">0</span>),
            <span class="dt">searches =</span> <span class="kw">n</span>(), <span class="dt">ctr =</span> clickthroughs/searches) %&gt;%
<span class="st">  </span>ungroup
engagement_overall &lt;-<span class="st"> </span><span class="kw">cbind</span>(
  engagement_overall,
  <span class="kw">as.data.frame</span>(
    binom:::<span class="kw">binom.bayes</span>(
      engagement_overall$clickthroughs,
      <span class="dt">n =</span> engagement_overall$searches)[, <span class="kw">c</span>(<span class="st">&quot;mean&quot;</span>, <span class="st">&quot;lower&quot;</span>, <span class="st">&quot;upper&quot;</span>)]
    )
  )</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">engagement_overall %&gt;%
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">y =</span> mean, <span class="dt">color =</span> <span class="st">`</span><span class="dt">test group</span><span class="st">`</span>)) +
<span class="st">  </span><span class="kw">geom_hline</span>(<span class="kw">aes</span>(<span class="dt">yintercept =</span> mean), <span class="dt">linetype =</span> <span class="st">&quot;dashed&quot;</span>, <span class="dt">color =</span> RColorBrewer::<span class="kw">brewer.pal</span>(<span class="dv">3</span>, <span class="st">&quot;Set1&quot;</span>)[<span class="dv">1</span>],
             <span class="dt">data =</span> <span class="kw">filter</span>(engagement_overall, <span class="st">`</span><span class="dt">test group</span><span class="st">`</span> ==<span class="st"> &quot;Control Group (tf–idf)&quot;</span>)) +
<span class="st">  </span><span class="kw">geom_pointrange</span>(<span class="kw">aes</span>(<span class="dt">ymin =</span> lower, <span class="dt">ymax =</span> upper), <span class="dt">position =</span> <span class="kw">position_dodge</span>(<span class="dt">width =</span> <span class="dv">1</span>)) +
<span class="st">  </span><span class="kw">scale_color_brewer</span>(<span class="st">&quot;Test Group&quot;</span>, <span class="dt">palette =</span> <span class="st">&quot;Set1&quot;</span>, <span class="dt">guide =</span> <span class="kw">guide_legend</span>(<span class="dt">ncol =</span> <span class="dv">2</span>)) +
<span class="st">  </span><span class="kw">scale_y_continuous</span>(<span class="dt">labels =</span> scales::<span class="kw">percent_format</span>(), <span class="dt">expand =</span> <span class="kw">c</span>(<span class="fl">0.01</span>, <span class="fl">0.01</span>)) +
<span class="st">  </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="ot">NULL</span>, <span class="dt">y =</span> <span class="st">&quot;Clickthrough rate&quot;</span>,
       <span class="dt">title =</span> <span class="st">&quot;Engagement with search results by test group&quot;</span>) +
<span class="st">  </span><span class="kw">geom_text</span>(<span class="kw">aes</span>(<span class="dt">label =</span> <span class="kw">sprintf</span>(<span class="st">&quot;%.1f%%&quot;</span>, <span class="dv">100</span> *<span class="st"> </span>ctr), <span class="dt">y =</span> upper +<span class="st"> </span><span class="fl">0.0025</span>, <span class="dt">vjust =</span> <span class="st">&quot;bottom&quot;</span>),
            <span class="dt">position =</span> <span class="kw">position_dodge</span>(<span class="dt">width =</span> <span class="dv">1</span>)) +
<span class="st">  </span><span class="kw">theme_minimal</span>(<span class="dt">base_family =</span> <span class="st">&quot;Lato&quot;</span>) +
<span class="st">  </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">&quot;bottom&quot;</span>)</code></pre></div>
<div class="figure">
<img src="index_files/figure-html/engagement_overall_eda-1.png" alt="Figure 5: Clickthrough rates of test groups." />
<p class="caption"><strong>Figure 5</strong>: Clickthrough rates of test groups.</p>
</div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Figure out engagement (clickthroughs) on a per-search (&quot;query cluster&quot;) basis:</span>
per_search_engagement &lt;-<span class="st"> </span>query_reformulations %&gt;%
<span class="st">  </span><span class="kw">filter</span>(results ==<span class="st"> &quot;some&quot;</span>) %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(<span class="st">`</span><span class="dt">test group</span><span class="st">`</span>, linkage,
           <span class="dt">search =</span> <span class="kw">paste</span>(search_id, cluster),
           <span class="dt">reformulated =</span> reformulations &gt;<span class="st"> </span><span class="dv">0</span>) %&gt;%
<span class="st">  </span><span class="kw">summarize</span>(<span class="dt">clickthroughs =</span> <span class="kw">sum</span>(clickthrough), <span class="st">`</span><span class="dt">non-ZR searches</span><span class="st">`</span> =<span class="st"> </span><span class="kw">n</span>())

engagement &lt;-<span class="st"> </span>per_search_engagement %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(<span class="st">`</span><span class="dt">test group</span><span class="st">`</span>, linkage,
           <span class="dt">reformulated =</span> <span class="kw">ifelse</span>(reformulated, <span class="st">&quot;reformulated query&quot;</span>, <span class="st">&quot;did not reformulate query&quot;</span>)) %&gt;%
<span class="st">  </span><span class="kw">summarize</span>(<span class="dt">clickthroughs =</span> <span class="kw">sum</span>(clickthroughs &gt;<span class="st"> </span><span class="dv">0</span>),
            <span class="dt">searches =</span> <span class="kw">n</span>(), <span class="dt">ctr =</span> clickthroughs/searches) %&gt;%
<span class="st">  </span>ungroup
engagement &lt;-<span class="st"> </span><span class="kw">cbind</span>(
  engagement,
  <span class="kw">as.data.frame</span>(
    binom:::<span class="kw">binom.bayes</span>(
      engagement$clickthroughs,
      <span class="dt">n =</span> engagement$searches)[, <span class="kw">c</span>(<span class="st">&quot;mean&quot;</span>, <span class="st">&quot;lower&quot;</span>, <span class="st">&quot;upper&quot;</span>)]
    )
  )</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">engagement %&gt;%
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">y =</span> mean, <span class="dt">color =</span> <span class="st">`</span><span class="dt">test group</span><span class="st">`</span>)) +
<span class="st">  </span><span class="kw">geom_hline</span>(<span class="kw">aes</span>(<span class="dt">yintercept =</span> mean), <span class="dt">linetype =</span> <span class="st">&quot;dashed&quot;</span>, <span class="dt">color =</span> RColorBrewer::<span class="kw">brewer.pal</span>(<span class="dv">3</span>, <span class="st">&quot;Set1&quot;</span>)[<span class="dv">1</span>],
             <span class="dt">data =</span> <span class="kw">filter</span>(engagement, <span class="st">`</span><span class="dt">test group</span><span class="st">`</span> ==<span class="st"> &quot;Control Group (tf–idf)&quot;</span>)) +
<span class="st">  </span><span class="kw">geom_pointrange</span>(<span class="kw">aes</span>(<span class="dt">ymin =</span> lower, <span class="dt">ymax =</span> upper), <span class="dt">position =</span> <span class="kw">position_dodge</span>(<span class="dt">width =</span> <span class="dv">1</span>)) +
<span class="st">  </span><span class="kw">facet_grid</span>(reformulated ~<span class="st"> </span>linkage, <span class="dt">scales =</span> <span class="st">&quot;free_y&quot;</span>) +
<span class="st">  </span><span class="kw">scale_color_brewer</span>(<span class="st">&quot;Test Group&quot;</span>, <span class="dt">palette =</span> <span class="st">&quot;Set1&quot;</span>, <span class="dt">guide =</span> <span class="kw">guide_legend</span>(<span class="dt">ncol =</span> <span class="dv">2</span>)) +
<span class="st">  </span><span class="kw">scale_y_continuous</span>(<span class="dt">labels =</span> scales::<span class="kw">percent_format</span>(), <span class="dt">expand =</span> <span class="kw">c</span>(<span class="fl">0.01</span>, <span class="fl">0.01</span>)) +
<span class="st">  </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="ot">NULL</span>, <span class="dt">y =</span> <span class="st">&quot;Clickthrough rate&quot;</span>,
       <span class="dt">title =</span> <span class="st">&quot;Engagement with search results by test group and presence of query reformulation&quot;</span>,
       <span class="dt">subtitle =</span> <span class="st">&quot;Queries were grouped via hierarchical clustering using average/complete/single linkage and edit distance adjusted by search results in common&quot;</span>) +
<span class="st">  </span><span class="kw">geom_text</span>(<span class="kw">aes</span>(<span class="dt">label =</span> <span class="kw">sprintf</span>(<span class="st">&quot;%.1f%%&quot;</span>, <span class="dv">100</span> *<span class="st"> </span>ctr), <span class="dt">y =</span> upper +<span class="st"> </span><span class="fl">0.005</span>, <span class="dt">vjust =</span> <span class="st">&quot;bottom&quot;</span>),
            <span class="dt">position =</span> <span class="kw">position_dodge</span>(<span class="dt">width =</span> <span class="dv">1</span>)) +
<span class="st">  </span><span class="kw">theme_minimal</span>(<span class="dt">base_family =</span> <span class="st">&quot;Lato&quot;</span>) +
<span class="st">  </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">&quot;bottom&quot;</span>,
        <span class="dt">panel.grid.major.x =</span> <span class="kw">element_blank</span>(),
        <span class="dt">panel.grid.minor.x =</span> <span class="kw">element_blank</span>(),
        <span class="dt">axis.ticks.x =</span> <span class="kw">element_blank</span>(),
        <span class="dt">axis.text.x =</span> <span class="kw">element_blank</span>(),
        <span class="dt">strip.background =</span> <span class="kw">element_rect</span>(<span class="dt">fill =</span> <span class="st">&quot;gray90&quot;</span>),
        <span class="dt">panel.border =</span> <span class="kw">element_rect</span>(<span class="dt">color =</span> <span class="st">&quot;gray30&quot;</span>, <span class="dt">fill =</span> <span class="ot">NA</span>))</code></pre></div>
<div class="figure">
<img src="index_files/figure-html/engagement_eda-1.png" alt="Figure 6: Clickthrough rates of test groups after splitting searches into those having query reformulations and those without query reformulations." />
<p class="caption"><strong>Figure 6</strong>: Clickthrough rates of test groups after splitting searches into those having query reformulations and those without query reformulations.</p>
</div>
</div>
<div id="first-clicked-results-position" class="section level3">
<h3>First Clicked Result’s Position</h3>
<p>In Figure 7, we see that <span class="test-group-2">users who got the “all-field” query builder with BM25</span> were much less likely to click on the first search result first than the other groups. Other test groups (whose search configurations used incoming links) first clicked on the first result at a much higher rate than users in <span class="test-group-1">the control group</span>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">safe_ordinals &lt;-<span class="st"> </span>function(x) {
  <span class="kw">return</span>(<span class="kw">vapply</span>(x, toOrdinal::toOrdinal, <span class="st">&quot;&quot;</span>))
}
first_clicked &lt;-<span class="st"> </span>searches %&gt;%
<span class="st">  </span><span class="kw">filter</span>(results ==<span class="st"> &quot;some&quot;</span> &amp;<span class="st"> </span>clickthrough &amp;<span class="st"> </span>!<span class="kw">is.na</span>(<span class="st">`</span><span class="dt">first clicked result&#39;s position</span><span class="st">`</span>)) %&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="st">`</span><span class="dt">first clicked result&#39;s position</span><span class="st">`</span> =<span class="st"> </span><span class="kw">ifelse</span>(<span class="st">`</span><span class="dt">first clicked result&#39;s position</span><span class="st">`</span> &lt;<span class="st"> </span><span class="dv">4</span>, <span class="kw">safe_ordinals</span>(<span class="st">`</span><span class="dt">first clicked result&#39;s position</span><span class="st">`</span> +<span class="st"> </span><span class="dv">1</span>), <span class="st">&quot;5th or higher&quot;</span>)) %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(<span class="st">`</span><span class="dt">test group</span><span class="st">`</span>, <span class="st">`</span><span class="dt">first clicked result&#39;s position</span><span class="st">`</span>) %&gt;%
<span class="st">  </span>tally %&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">total =</span> <span class="kw">sum</span>(n), <span class="dt">prop =</span> n/total) %&gt;%
<span class="st">  </span>ungroup
<span class="kw">set.seed</span>(<span class="dv">0</span>)
temp &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(binom:::<span class="kw">binom.bayes</span>(first_clicked$n, <span class="dt">n =</span> first_clicked$total, <span class="dt">tol =</span> .Machine$double.eps^<span class="fl">0.1</span>)[, <span class="kw">c</span>(<span class="st">&quot;mean&quot;</span>, <span class="st">&quot;lower&quot;</span>, <span class="st">&quot;upper&quot;</span>)])
first_clicked &lt;-<span class="st"> </span><span class="kw">cbind</span>(first_clicked, temp); <span class="kw">rm</span>(temp)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">first_clicked %&gt;%
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">y =</span> mean, <span class="dt">color =</span> <span class="st">`</span><span class="dt">test group</span><span class="st">`</span>)) +
<span class="st">  </span><span class="kw">geom_hline</span>(
    <span class="kw">aes</span>(<span class="dt">yintercept =</span> mean), 
    <span class="dt">linetype =</span> <span class="st">&quot;dashed&quot;</span>, <span class="dt">color =</span> RColorBrewer::<span class="kw">brewer.pal</span>(<span class="dv">3</span>, <span class="st">&quot;Set1&quot;</span>)[<span class="dv">1</span>],
    <span class="dt">data =</span> <span class="kw">filter</span>(first_clicked, <span class="st">`</span><span class="dt">test group</span><span class="st">`</span> ==<span class="st"> &quot;Control Group (tf–idf)&quot;</span>)
  ) +
<span class="st">  </span><span class="kw">geom_pointrange</span>(<span class="kw">aes</span>(<span class="dt">ymin =</span> lower, <span class="dt">ymax =</span> upper), <span class="dt">position =</span> <span class="kw">position_dodge</span>(<span class="dt">width =</span> <span class="dv">1</span>)) +
<span class="st">  </span><span class="kw">geom_text</span>(<span class="kw">aes</span>(<span class="dt">label =</span> <span class="kw">sprintf</span>(<span class="st">&quot;%.1f&quot;</span>, <span class="dv">100</span> *<span class="st"> </span>prop), <span class="dt">y =</span> upper +<span class="st"> </span><span class="fl">0.0025</span>, <span class="dt">vjust =</span> <span class="st">&quot;bottom&quot;</span>),
            <span class="dt">position =</span> <span class="kw">position_dodge</span>(<span class="dt">width =</span> <span class="dv">1</span>)) +
<span class="st">  </span><span class="kw">scale_y_continuous</span>(<span class="dt">labels =</span> scales::<span class="kw">percent_format</span>(),
                     <span class="dt">expand =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="fl">0.005</span>), <span class="dt">breaks =</span> <span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="fl">0.01</span>)) +
<span class="st">  </span><span class="kw">scale_color_brewer</span>(<span class="st">&quot;Test Group&quot;</span>, <span class="dt">palette =</span> <span class="st">&quot;Set1&quot;</span>, <span class="dt">guide =</span> <span class="kw">guide_legend</span>(<span class="dt">ncol =</span> <span class="dv">2</span>)) +
<span class="st">  </span><span class="kw">facet_wrap</span>(~<span class="st"> `</span><span class="dt">first clicked result&#39;s position</span><span class="st">`</span>, <span class="dt">scale =</span> <span class="st">&quot;free_y&quot;</span>, <span class="dt">nrow =</span> <span class="dv">1</span>) +
<span class="st">  </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="ot">NULL</span>, <span class="dt">y =</span> <span class="st">&quot;Proportion of searches&quot;</span>,
       <span class="dt">title =</span> <span class="st">&quot;Position of the first clicked result&quot;</span>,
       <span class="dt">subtitle =</span> <span class="st">&quot;With 95% credible intervals&quot;</span>) +
<span class="st">  </span><span class="kw">theme_minimal</span>(<span class="dt">base_family =</span> <span class="st">&quot;Lato&quot;</span>) +
<span class="st">  </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">&quot;bottom&quot;</span>,
        <span class="dt">panel.grid.major.x =</span> <span class="kw">element_blank</span>(),
        <span class="dt">panel.grid.minor.x =</span> <span class="kw">element_blank</span>(),
        <span class="dt">axis.ticks.x =</span> <span class="kw">element_blank</span>(),
        <span class="dt">axis.text.x =</span> <span class="kw">element_blank</span>(),
        <span class="dt">strip.background =</span> <span class="kw">element_rect</span>(<span class="dt">fill =</span> <span class="st">&quot;gray90&quot;</span>),
        <span class="dt">panel.border =</span> <span class="kw">element_rect</span>(<span class="dt">color =</span> <span class="st">&quot;gray30&quot;</span>, <span class="dt">fill =</span> <span class="ot">NA</span>))</code></pre></div>
<div class="figure">
<img src="index_files/figure-html/first_clicked_position_eda-1.png" alt="Figure 7: First clicked result’s position by group." />
<p class="caption"><strong>Figure 7</strong>: First clicked result’s position by group.</p>
</div>
</div>
</div>
<div id="conclusion" class="section level2">
<h2>Conclusion</h2>
<p>We recommend switching to BM25 ranking with incoming links (and possibly pageviews) as query-independent factors, as this configuration appears to give users results that are more relevant and that they engage with more (especially the first search result).</p>
</div>
<div id="references" class="section level2">
<h2>References</h2>
<div id="reading" class="section level3">
<h3>Reading</h3>
<ol>
<li id="ref-1">
<a href = "https://www.mediawiki.org/wiki/Wikimedia_Discovery/Search/Glossary">Wikimedia Discovery/Search/Glossary</a>
</li>
</ol>
</div>
<div id="software-1" class="section level3">
<h3>Software</h3>
<ol start="2" style="list-style-type: decimal">
<li id="ref-2">
R Core Team (2016). <em>R: A Language and Environment for StatisticalComputing</em>. R Foundation for Statistical Computing, Vienna,Austria. <a href="https://www.R-project.org/" class="uri">https://www.R-project.org/</a>
</li>
<li id="ref-3">
Bache SM and Wickham H (2014). <em>magrittr: A Forward-Pipe Operatorfor R</em>. R package version 1.5, <a href="https://CRAN.R-project.org/package=magrittr" class="uri">https://CRAN.R-project.org/package=magrittr</a>
</li>
<li id="ref-4">
Wickham H (2009). <em>ggplot2: Elegant Graphics for Data Analysis</em>.Springer-Verlag New York. ISBN 978-0-387-98140-6, <a href="http://ggplot2.org" class="uri">http://ggplot2.org</a>
</li>
<li id="ref-5">
Wickham H and Francois R (2016). <em>dplyr: A Grammar of DataManipulation</em>. R package version 0.5.0, <a href="https://CRAN.R-project.org/package=dplyr" class="uri">https://CRAN.R-project.org/package=dplyr</a>
</li>
<li id="ref-6">
Wickham H (2016). <em>tidyr: Easily Tidy Data with <code>spread()</code> and<code>gather()</code> Functions</em>. R package version 0.6.0, <a href="https://CRAN.R-project.org/package=tidyr" class="uri">https://CRAN.R-project.org/package=tidyr</a>
</li>
<li id="ref-7">
Wickham H, Hester J and Francois R (2016). <em>readr: Read TabularData</em>. R package version 1.0.0, <a href="https://CRAN.R-project.org/package=readr" class="uri">https://CRAN.R-project.org/package=readr</a>
</li>
<li id="ref-8">
Dorai-Raj S (2014). <em>binom: Binomial Confidence Intervals ForSeveral Parameterizations</em>. R package version 1.1-1, <a href="https://CRAN.R-project.org/package=binom" class="uri">https://CRAN.R-project.org/package=binom</a>
</li>
<li id="ref-9">
Allaire J, Cheng J, Xie Y, McPherson J, Chang W, Allen J, WickhamH, Atkins A and Hyndman R (2016). <em>rmarkdown: Dynamic Documentsfor R</em>. R package version 1.0, <a href="https://CRAN.R-project.org/package=rmarkdown" class="uri">https://CRAN.R-project.org/package=rmarkdown</a>
</li>
<li id="ref-10">
Xie Y (2016). <em>knitr: A General-Purpose Package for Dynamic ReportGeneration in R</em>. R package version 1.14, <a href="http://yihui.name/knitr/" class="uri">http://yihui.name/knitr/</a>
</li>
<li id="ref-11">
Xie Y (2015). <em>Dynamic Documents with R and knitr</em>, 2nd edition.Chapman and Hall/CRC, Boca Raton, Florida. ISBN 978-1498716963, <a href="http://yihui.name/knitr/" class="uri">http://yihui.name/knitr/</a>
</li>
<li id="ref-12">
Xie Y (2014). “knitr: A Comprehensive Tool for ReproducibleResearch in R.” In Stodden V, Leisch F and Peng RD (eds.),<em>Implementing Reproducible Computational Research</em>. Chapman andHall/CRC. ISBN 978-1466561595, <a href="http://www.crcpress.com/product/isbn/9781466561595" class="uri">http://www.crcpress.com/product/isbn/9781466561595</a>
</li>
</ol>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
$(document).ready(function () {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
});

</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://tools-static.wmflabs.org/cdnjs/ajax/libs/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
